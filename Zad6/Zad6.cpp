//--------------------------------------------------------------------------------
// Code generated by jFuzzyLogic
// jFuzzyLogic Version : JFuzzyLogic 3.3 (build 2015-04-09), by Pablo Cingolani 
// jFuzzyLogic creted by Pablo Cingolani
//--------------------------------------------------------------------------------


#include <stdio.h>

#include <stdlib.h>
double ruleAccumulationMethod_max(double defuzzifierValue, double valueToAggregate)	{ return ( defuzzifierValue > valueToAggregate ? defuzzifierValue : valueToAggregate ); }

double ruleActivationMethod_min(double degreeOfSupport, double membership)	{ return (degreeOfSupport < membership ? degreeOfSupport : membership); }

double ruleConnectionMethod_and(double antecedent1, double antecedent2)	{ return (antecedent1 < antecedent2 ? antecedent1 : antecedent2); }

class FunctionBlock_Car {

	public: 
	// VAR_INPUT
	double dystans;
	double predkosc;

	// VAR_OUTPUT
	double przyspieszenie;

	private: 
	// FUZZIFY dystans
	double dystans_dlugi;
	double dystans_krotki;

	// FUZZIFY predkosc
	double predkosc_duza;
	double predkosc_mala;


	// DEFUZZIFY przyspieszenie
	double defuzzify_przyspieszenie[1000];


	public:
	FunctionBlock_Car();
	void calc();
	void print();

	private:
	void defuzzify();
	void fuzzify();
	void reset();
	double membership_dystans_dlugi(double x);
	double membership_dystans_krotki(double x);
	double membership_predkosc_duza(double x);
	double membership_predkosc_mala(double x);
	double membership_przyspieszenie_utrzymaj_predkosc(double x);
	double membership_przyspieszenie_zredukuj_predkosc(double x);
	double membership_przyspieszenie_zwieksz_predkosc(double x);
	void calc_No1();

};

// Constructor
FunctionBlock_Car::FunctionBlock_Car() {
	przyspieszenie = 0.0;
}

// Calculate function block
void FunctionBlock_Car::calc() {
	reset();
	fuzzify();
	calc_No1();
	defuzzify();
}

// RULEBLOCK No1
void FunctionBlock_Car::calc_No1() {
	// RULE 1 : IF (dystans IS krotki) AND (predkosc IS mala) THEN przyspieszenie IS utrzymaj_predkosc;
	double degreeOfSupport_1 = 1.0 * ( ruleConnectionMethod_and(dystans_krotki , predkosc_mala) );
	if( degreeOfSupport_1 > 0 ) {
		for (int i = 0 ; i < 1000 ; i++ ) {
			double x = -20.0 + i * 0.04;
			double membership = membership_przyspieszenie_utrzymaj_predkosc(x);
			double y = ruleActivationMethod_min( degreeOfSupport_1 , membership );
			defuzzify_przyspieszenie[i] += ruleAccumulationMethod_max( defuzzify_przyspieszenie[i], y );
		}
	}

	// RULE 2 : IF (dystans IS krotki) AND (predkosc IS duza) THEN przyspieszenie IS zredukuj_predkosc;
	double degreeOfSupport_2 = 1.0 * ( ruleConnectionMethod_and(dystans_krotki , predkosc_duza) );
	if( degreeOfSupport_2 > 0 ) {
		for (int i = 0 ; i < 1000 ; i++ ) {
			double x = -20.0 + i * 0.04;
			double membership = membership_przyspieszenie_zredukuj_predkosc(x);
			double y = ruleActivationMethod_min( degreeOfSupport_2 , membership );
			defuzzify_przyspieszenie[i] += ruleAccumulationMethod_max( defuzzify_przyspieszenie[i], y );
		}
	}

	// RULE 3 : IF (dystans IS dlugi) AND (predkosc IS mala) THEN przyspieszenie IS zwieksz_predkosc;
	double degreeOfSupport_3 = 1.0 * ( ruleConnectionMethod_and(dystans_dlugi , predkosc_mala) );
	if( degreeOfSupport_3 > 0 ) {
		for (int i = 0 ; i < 1000 ; i++ ) {
			double x = -20.0 + i * 0.04;
			double membership = membership_przyspieszenie_zwieksz_predkosc(x);
			double y = ruleActivationMethod_min( degreeOfSupport_3 , membership );
			defuzzify_przyspieszenie[i] += ruleAccumulationMethod_max( defuzzify_przyspieszenie[i], y );
		}
	}

	// RULE 4 : IF (dystans IS dlugi) AND (predkosc IS duza) THEN przyspieszenie IS utrzymaj_predkosc;
	double degreeOfSupport_4 = 1.0 * ( ruleConnectionMethod_and(dystans_dlugi , predkosc_duza) );
	if( degreeOfSupport_4 > 0 ) {
		for (int i = 0 ; i < 1000 ; i++ ) {
			double x = -20.0 + i * 0.04;
			double membership = membership_przyspieszenie_utrzymaj_predkosc(x);
			double y = ruleActivationMethod_min( degreeOfSupport_4 , membership );
			defuzzify_przyspieszenie[i] += ruleAccumulationMethod_max( defuzzify_przyspieszenie[i], y );
		}
	}

}

// Defuzzify 
void FunctionBlock_Car::defuzzify() {
	double sum_przyspieszenie = 0.0;
	double wsum_przyspieszenie = 0.0;
	for (int i = 0; i < 1000 ; i++ ) {
		double x = -20.0 + i * 0.04;
		sum_przyspieszenie += defuzzify_przyspieszenie[i];
		wsum_przyspieszenie += x * defuzzify_przyspieszenie[i];
	}
	przyspieszenie = wsum_przyspieszenie / sum_przyspieszenie;
}

// Fuzzify all variables
void FunctionBlock_Car::fuzzify() {
	dystans_dlugi = membership_dystans_dlugi(dystans);
	dystans_krotki = membership_dystans_krotki(dystans);
	predkosc_duza = membership_predkosc_duza(predkosc);
	predkosc_mala = membership_predkosc_mala(predkosc);
}

// Membership functions 
double FunctionBlock_Car::membership_dystans_dlugi(double x) {
	if ( x <= 200.0 )	return 0.0;
	if ( x > 1000.0 )	return 1.0;
	if ( x <= 400.0 )	return 0.0 + ( 1.0 - 0.0 ) * ( ( x - 200.0 ) / ( 400.0 - 200.0 ) );
	if ( x <= 1000.0 )	return 1.0 + ( 1.0 - 1.0 ) * ( ( x - 400.0 ) / ( 1000.0 - 400.0 ) );
}

double FunctionBlock_Car::membership_dystans_krotki(double x) {
	if ( x <= 0.0 )	return 1.0;
	if ( x > 400.0 )	return 0.0;
	if ( x <= 200.0 )	return 1.0 + ( 1.0 - 1.0 ) * ( ( x - 0.0 ) / ( 200.0 - 0.0 ) );
	if ( x <= 400.0 )	return 1.0 + ( 0.0 - 1.0 ) * ( ( x - 200.0 ) / ( 400.0 - 200.0 ) );
}

double FunctionBlock_Car::membership_predkosc_duza(double x) {
	if ( x <= 20.0 )	return 0.0;
	if ( x > 80.0 )	return 1.0;
	if ( x <= 40.0 )	return 0.0 + ( 1.0 - 0.0 ) * ( ( x - 20.0 ) / ( 40.0 - 20.0 ) );
	if ( x <= 80.0 )	return 1.0 + ( 1.0 - 1.0 ) * ( ( x - 40.0 ) / ( 80.0 - 40.0 ) );
}

double FunctionBlock_Car::membership_predkosc_mala(double x) {
	if ( x <= 0.0 )	return 1.0;
	if ( x > 40.0 )	return 0.0;
	if ( x <= 20.0 )	return 1.0 + ( 1.0 - 1.0 ) * ( ( x - 0.0 ) / ( 20.0 - 0.0 ) );
	if ( x <= 40.0 )	return 1.0 + ( 0.0 - 1.0 ) * ( ( x - 20.0 ) / ( 40.0 - 20.0 ) );
}

double FunctionBlock_Car::membership_przyspieszenie_utrzymaj_predkosc(double x) {
	if ( x <= -10.0 )	return 0.0;
	if ( x > 10.0 )	return 0.0;
	if ( x <= 0.0 )	return 0.0 + ( 1.0 - 0.0 ) * ( ( x - -10.0 ) / ( 0.0 - -10.0 ) );
	if ( x <= 10.0 )	return 1.0 + ( 0.0 - 1.0 ) * ( ( x - 0.0 ) / ( 10.0 - 0.0 ) );
}

double FunctionBlock_Car::membership_przyspieszenie_zredukuj_predkosc(double x) {
	if ( x <= -20.0 )	return 1.0;
	if ( x > 0.0 )	return 0.0;
	if ( x <= -10.0 )	return 1.0 + ( 1.0 - 1.0 ) * ( ( x - -20.0 ) / ( -10.0 - -20.0 ) );
	if ( x <= 0.0 )	return 1.0 + ( 0.0 - 1.0 ) * ( ( x - -10.0 ) / ( 0.0 - -10.0 ) );
}

double FunctionBlock_Car::membership_przyspieszenie_zwieksz_predkosc(double x) {
	if ( x <= 0.0 )	return 0.0;
	if ( x > 20.0 )	return 1.0;
	if ( x <= 10.0 )	return 0.0 + ( 1.0 - 0.0 ) * ( ( x - 0.0 ) / ( 10.0 - 0.0 ) );
	if ( x <= 20.0 )	return 1.0 + ( 1.0 - 1.0 ) * ( ( x - 10.0 ) / ( 20.0 - 10.0 ) );
}


// Print 
void FunctionBlock_Car::print() {
	printf("Function block Car:\n");
	printf("	Input  %20s : %f\n", "dystans" , dystans);
	printf("	       %20s : %f\n", "dystans_dlugi" , dystans_dlugi);
	printf("	       %20s : %f\n", "dystans_krotki" , dystans_krotki);
	printf("	Input  %20s : %f\n", "predkosc" , predkosc);
	printf("	       %20s : %f\n", "predkosc_duza" , predkosc_duza);
	printf("	       %20s : %f\n", "predkosc_mala" , predkosc_mala);
	printf("	Output %20s : %f\n", "przyspieszenie" , przyspieszenie);
}

// Reset output
void FunctionBlock_Car::reset() {
	for( int i=0 ; i < 1000 ; i++ )	{ defuzzify_przyspieszenie[i] = 0.0; }
}

int main(int argc, char *argv[]) {
	// Create function blocks
	FunctionBlock_Car Car;

	// Parse input
	if( argc > 1 ) { Car.dystans = atof(argv[1]); }
	if( argc > 2 ) { Car.predkosc = atof(argv[2]); }
	
	while (Car.dystans >= 0)
	{
		Car.calc();
		Car.print();
		Car.dystans = Car.dystans - 10;
	};
	
}
